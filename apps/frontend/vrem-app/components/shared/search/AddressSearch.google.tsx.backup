'use client';

import { useState, useEffect, useCallback } from 'react';
import { Input } from '../../ui/input';
import { MapPin, Search, Sparkles, AlertCircle } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

interface AddressSearchProps {
  onAddressSelect: (address: string, location: { lat: number; lng: number }) => void;
}

interface PlacePrediction {
  description: string;
  place_id: string;
  structured_formatting: {
    main_text: string;
    secondary_text: string;
  };
}

// Declare global google types
declare global {
  interface Window {
    google: typeof google;
    initGoogleMaps: () => void;
  }
}

export function AddressSearch({ onAddressSelect }: AddressSearchProps) {
  const [query, setQuery] = useState('');
  const [isFocused, setIsFocused] = useState(false);
  const [predictions, setPredictions] = useState<PlacePrediction[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isGoogleLoaded, setIsGoogleLoaded] = useState(false);

  // Load Google Maps API
  useEffect(() => {
    const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;
    
    if (!apiKey) {
      setError('Google Maps API key not configured');
      console.warn('Please add NEXT_PUBLIC_GOOGLE_MAPS_API_KEY to your .env.local file');
      return;
    }

    // Check if already loaded
    if (window.google && window.google.maps) {
      setIsGoogleLoaded(true);
      return;
    }

    // Load Google Maps script
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places&callback=initGoogleMaps`;
    script.async = true;
    script.defer = true;

    window.initGoogleMaps = () => {
      setIsGoogleLoaded(true);
      setError(null);
    };

    script.onerror = () => {
      setError('Failed to load Google Maps');
      console.error('Error loading Google Maps script');
    };

    document.head.appendChild(script);

    return () => {
      // Cleanup
      if (window.initGoogleMaps) {
        window.initGoogleMaps = () => {};
      }
    };
  }, []);

  // Fetch predictions when query changes
  useEffect(() => {
    if (!query || query.length < 3 || !isGoogleLoaded) {
      setPredictions([]);
      return;
    }

    setIsLoading(true);

    const autocompleteService = new google.maps.places.AutocompleteService();
    const request = {
      input: query,
      types: ['address'],
      componentRestrictions: { country: ['us', 'ca'] }, // USA and Canada
    };

    autocompleteService.getPlacePredictions(
      request,
      (predictions, status) => {
        setIsLoading(false);
        
        if (status === google.maps.places.PlacesServiceStatus.OK && predictions) {
          setPredictions(predictions as PlacePrediction[]);
        } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
          setPredictions([]);
        } else {
          console.error('AutocompleteService error:', status);
        }
      }
    );
  }, [query, isGoogleLoaded]);

  const handlePlaceSelect = useCallback(async (prediction: PlacePrediction) => {
    if (!isGoogleLoaded) {
      console.error('Google Maps not loaded');
      return;
    }

    setQuery(prediction.description);
    setPredictions([]);
    setIsFocused(false);
    setIsLoading(true);

    try {
      const geocoder = new google.maps.Geocoder();
      
      geocoder.geocode(
        { placeId: prediction.place_id },
        (results, status) => {
          setIsLoading(false);

          if (status === google.maps.GeocoderStatus.OK && results && results[0]) {
            const location = results[0].geometry.location;
            onAddressSelect(prediction.description, {
              lat: location.lat(),
              lng: location.lng(),
            });
          } else {
            console.error('Geocoding error:', status);
            setError('Failed to get address coordinates');
          }
        }
      );
    } catch (err) {
      console.error('Error geocoding address:', err);
      setError('Failed to process address');
      setIsLoading(false);
    }
  }, [isGoogleLoaded, onAddressSelect]);

  return (
    <div className="relative w-full max-w-3xl mx-auto">
      <motion.div
        initial={{ scale: 0.95, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ duration: 0.3 }}
      >
        {/* Search Input */}
        <div className="relative">
          <div className="absolute left-5 top-1/2 -translate-y-1/2 flex items-center gap-3">
            <Search className="h-6 w-6 text-muted-foreground/60" />
          </div>
          <Input
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onFocus={() => setIsFocused(true)}
            placeholder="Enter property address..."
            className="h-16 pl-16 pr-6 text-lg rounded-2xl border-2 border-border shadow-lg focus:border-black focus:ring-4 focus:ring-slate-100 transition-all"
            disabled={!!error && !isGoogleLoaded}
          />
          {isLoading ? (
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              className="absolute right-5 top-1/2 -translate-y-1/2"
            >
              <div className="h-5 w-5 border-2 border-border border-t-black rounded-full animate-spin" />
            </motion.div>
          ) : query && (
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              className="absolute right-5 top-1/2 -translate-y-1/2"
            >
              <Sparkles className="h-5 w-5 text-foreground" />
            </motion.div>
          )}
        </div>

        {/* Error Message */}
        {error && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            className="mt-2 p-3 bg-destructive/10 border border-destructive/30 rounded-lg flex items-start gap-2"
          >
            <AlertCircle className="h-5 w-5 text-destructive flex-shrink-0 mt-0.5" />
            <div>
              <p className="text-sm text-red-800">{error}</p>
              <p className="text-xs text-destructive mt-1">
                Add NEXT_PUBLIC_GOOGLE_MAPS_API_KEY to your .env.local file
              </p>
            </div>
          </motion.div>
        )}

        {/* Google Places Predictions */}
        <AnimatePresence>
          {isFocused && predictions.length > 0 && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              transition={{ duration: 0.2 }}
              className="absolute top-full mt-2 w-full bg-card rounded-2xl border-2 border-border shadow-2xl overflow-hidden z-50"
            >
              <div className="p-3">
                <div className="text-xs text-muted-foreground/80 px-3 py-2 flex items-center gap-2">
                  <MapPin className="h-3 w-3" />
                  <span>Address suggestions from Google</span>
                </div>
                <div className="space-y-1 max-h-80 overflow-y-auto">
                  {predictions.map((prediction, index) => (
                    <motion.button
                      key={prediction.place_id}
                      initial={{ opacity: 0, x: -20 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ delay: index * 0.05 }}
                      onClick={() => handlePlaceSelect(prediction)}
                      className="w-full text-left p-3 rounded-xl hover:bg-muted/50 transition-colors group"
                    >
                      <div className="flex items-start gap-3">
                        <div className="p-2 bg-muted rounded-lg group-hover:bg-primary/5 transition-colors">
                          <MapPin className="h-5 w-5 text-muted-foreground group-hover:text-foreground" />
                        </div>
                        <div className="flex-1 min-w-0">
                          <div className="text-sm text-foreground font-medium">
                            {prediction.structured_formatting.main_text}
                          </div>
                          <div className="text-xs text-muted-foreground/80 mt-0.5 truncate">
                            {prediction.structured_formatting.secondary_text}
                          </div>
                        </div>
                      </div>
                    </motion.button>
                  ))}
                </div>
                <div className="px-3 py-2 mt-2 border-t border-slate-100">
                  <div className="flex items-center gap-1 text-xs text-muted-foreground/60">
                    <span>Powered by</span>
                    <span className="font-medium text-muted-foreground">Google Maps</span>
                  </div>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* No results message */}
        {isFocused && query.length >= 3 && predictions.length === 0 && !isLoading && isGoogleLoaded && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            className="absolute top-full mt-2 w-full bg-card rounded-2xl border-2 border-border shadow-2xl overflow-hidden z-50 p-6 text-center"
          >
            <MapPin className="h-12 w-12 mx-auto mb-2 text-muted-foreground/40" />
            <p className="text-sm text-muted-foreground">No addresses found</p>
            <p className="text-xs text-muted-foreground/80 mt-1">Try a different search term</p>
          </motion.div>
        )}

        {/* Click outside to close */}
        {isFocused && (
          <div
            className="fixed inset-0 -z-10"
            onClick={() => setIsFocused(false)}
          />
        )}
      </motion.div>
    </div>
  );
}
